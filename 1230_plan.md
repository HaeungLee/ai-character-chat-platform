# 1230 Plan — 실행 체크리스트 (2025-12-30)

목표: 현재 코드베이스의 강점(SSE 스트리밍, 채팅 저장/복구, 메모리 시스템, OpenRouter 연동)을 **하나의 일관된 “프롬프트/컨텍스트 파이프라인”**으로 묶어, 무료/저비용에서도 **텍스트 답변 품질을 안정적으로 끌어올릴 수 있는 기반**을 만든다.

참고 문서
- 1221_execution_roadmap.md (실행 우선순위 Top5)
- 1220_plan.md (캐릭터 위저드/로어북/예시대화 요구)

---

## Phase 0) 오늘의 범위 확정(문서/결정) — 30~60분

### 0.1 오늘 Done 정의
- “오늘”의 Done은 **코드 변경이 아니라** 아래 산출물 2개 완료로 정의한다.
  - `Prompt Assembly v1` 문서(프롬프트 조립 규칙/순서/토큰예산/AC)
  - `SSE Chat Pipeline v1` 문서(SSE 경로에서 어떤 데이터를 언제 저장/주입할지)

### 0.2 품질/비용 KPI(간단 버전)
- 품질(체감): 동일 캐릭터에서 캐릭터성 유지/설정 준수/회상(기억 반영) 3가지를 확인
- 비용(운영): 대화가 길어져도 컨텍스트가 무한히 커지지 않게(요약/메모리로 제한) 설계

---

## Phase 1) Prompt Assembly v1(핵심) — 1~2시간

현재 문제(현 상태)
- Socket.IO 경로에는 메모리(RAG) 주입이 연결돼 있지만, **프론트가 쓰는 SSE 경로는 메모리 주입이 없다.**
- 로어북/예시대화(페르소나 고정 장치)가 DB에 있어도, **OpenAI/OpenRouter 프롬프트에는 주입되지 않는다.**

### 1.1 프롬프트 조립 순서(권장 v1)
1) Base System Prompt(캐릭터 systemPrompt + personality)
2) Lorebook(키 트리거 기반) — “관련 항목만”
3) Few-shot Examples(예시대화) — “스타일 고정”
4) Memory/RAG(장기 기억) — “회상/사실 유지”
5) Recent Conversation History(최근 K개)
6) Current User Message

### 1.2 토큰 예산 규칙(운영 관점 v1)
- 목표: 컨텍스트의 성장은 “히스토리”가 아니라 “요약/메모리”가 담당하도록.
- Lorebook:
  - 키 트리거 매칭된 항목만 주입
  - 우선순위(priority)로 상위 N개 제한(예: 3~5개)
- Few-shot:
  - 캐릭터별 1~3개 세트(또는 토큰 예산 내)
- RAG:
  - 상위 K개 메모리만 주입(예: K=5)
  - 메모리 컨텍스트 총량 상한(예: 1500~2000 tokens) 유지
- Recent History:
  - 최근 K턴(예: 10~20 메시지)만 유지

### 1.3 주입 포맷(LLM 안전장치)
- 로어북/메모리 컨텍스트는 “사실/배경” 블록으로 넣되,
  - “기억을 직접적으로 언급하지 말 것”
  - “설정과 충돌 시 설정 우선”
  - “불확실하면 질문”

### 1.4 AC(수용 기준) — 오늘 문서에 반드시 포함
- (Lorebook) 특정 키워드가 포함된 유저 입력에서 해당 설정이 반영된다.
- (Examples) 같은 캐릭터에서 말투/어조가 예시대화와 유사하게 유지된다.
- (Memory) 이전에 사용자 프로필/관계를 언급하면 이후 대화에 자연스럽게 반영된다.
- (Fail-safe) 어떤 주입이 비어도 채팅 자체는 정상 동작한다(기능 플래그/옵션).

---

## Phase 2) SSE Chat Pipeline v1(데이터 흐름) — 1~2시간

목표
- 프론트 SSE 경로(`/api/ai/chat/stream`)에서도 Socket 경로처럼,
  1) 유저 메시지 저장
  2) RAG로 systemPrompt 보강
  3) 스트리밍
  4) 최종 assistant 메시지 저장
  5) 메모리 후처리(요약/중요정보 추출)
가 **같은 규칙**으로 동작하도록 설계를 문서화한다.

### 2.1 “대화 저장” 정책
- partial(스트리밍 중간)은 저장하지 않는다.
- done(fullResponse) 시점에만 assistant 메시지를 1회 저장한다.
- regenerate 시:
  - 기준 user 메시지 이후를 truncate
  - 다시 생성된 assistant만 저장

### 2.2 “메모리/요약” 정책
- afterMessageProcess는 user/assistant 모두 저장 대상으로(이미 Socket쪽은 그렇게 함)
- summarization job은 주기/임계치 기반으로(예: 10메시지마다 체크)

### 2.3 관측/디버깅 포인트
- requestId(또는 streamKey)로 프론트/백엔드 로그 상관관계 확보
- 스트리밍 오류/재시도 규칙 문서화(현재 프론트는 “무출력일 때 1회” 재시도)

---

## Phase 3) 제품화(무료/저비용/고품질) 운영 설계 — 30~60분

### 3.1 모델 라우팅(초안)
- Free(Default): 저비용 모델 1개
- Fallback: 품질/안정성 모델 1개(실패 시에만)
- Paid: 고품질 모델 1개(장문/스토리/롤플레잉에 최적)

### 3.2 제한/악용 방지(초안)
- per-user rate limit
- 일일 무료 메시지/토큰 예산(추후 과금 전환에 대비)

### 3.3 Usage/Cost 노출(초안)
- “이번 달 사용량/이번 대화 사용량”을 UI에서 확인 가능하게(운영 신뢰)

---

## Phase 4) 내일 이후 구현 우선순위(1230_plan을 따라 점진 구현)

실행 우선순위(권장)
1) Prompt Assembly 구현(공통 모듈화) → SSE/Socket/REST 경로에 동일 적용
2) Lorebook 키 트리거 + 예시대화 주입
3) RAG/Memory를 SSE 경로에 실제 연결
4) Explore(검색/태그) + 캐릭터 위저드 UX 정리
5) UsageTracking UI 노출

체크 포인트
- 각 단계마다 “AC 2~3개”로 완성 기준을 고정하고 진행한다.
