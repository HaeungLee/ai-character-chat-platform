# 1221 문제 해결 정리 (AI Character Chat Platform)

## TL;DR
- 채팅에서 보이던 `[Mock Response] ...`는 **LLM(OpenRouter) 문제가 아니라 프론트엔드가 setTimeout으로 응답을 직접 만들어서** 발생한 문제였다.
- 캐릭터 생성/목록도 프론트가 샘플/Mock 기반이어서 **"등록이 안 되는 것처럼" 보였고**, 백엔드도 샘플 캐릭터만 반환하도록 되어 있어 **실제 캐릭터 ID로는 AI 호출이 404**가 날 구조였다.
- 해결: 프론트를 **실제 API 호출 기반으로 전환**, 백엔드는 **Prisma 기반 캐릭터 API + AI 캐릭터 조회를 DB 기반으로 변경**, OpenRouter 호출 옵션을 연결했다.

---

## 1) 증상
1. 로그인 후 `http://localhost:3000/characters`에서 캐릭터가 제대로 생성/표시되지 않는 것처럼 보임
2. 채팅에서 “안녕” 입력 시 실제 LLM 응답이 아니라 아래 형태로 표시됨
   - `[Mock Response] "..."에 대한 반응입니다. (실제 LLM 연동 시 ...)`

---

## 2) 원인 분석

### A. 프론트엔드 채팅이 백엔드를 호출하지 않음
- 문제의 `[Mock Response]`는 OpenRouter/백엔드 문제가 아니라, 프론트의 채팅 페이지가 **setTimeout으로 Mock 문자열을 직접 주입**하는 로직 때문에 나타남.

### B. 캐릭터 생성/목록도 Mock 상태
- 캐릭터 생성 페이지가 실제 API 호출 없이 “대기 후 라우팅”만 수행하거나,
- 캐릭터 목록 페이지가 샘플 데이터만 그리도록 되어 있으면,
  - 사용자는 “캐릭터 등록이 안 된다”고 느끼게 됨.

### C. 백엔드도 샘플 캐릭터만 처리
- 백엔드 `AIController.getCharacterById`가 DB가 아니라 샘플 캐릭터(`sample_char_1` 등)만 반환하는 구조면,
  - 실제로 생성한 캐릭터 ID로 `/api/ai/chat` 호출 시 캐릭터 조회에서 실패(404) 가능.

---

## 3) 해결 내용 (핵심 변경)

### A. 프론트: Mock 제거 → 실제 API 호출
- 캐릭터 목록/생성/채팅 페이지를 Mock → 백엔드 API 호출로 전환
- 채팅 메시지 전송은 `/api/ai/chat` 호출로 변경
  - Body 예시:
    - `characterId`, `message`, `conversationHistory`, `provider: 'openrouter'`

### B. 프론트: 재생성(Regenerate)도 Mock 제거
- 기존: setTimeout으로 “(재생성된 답변)” 문자열 주입
- 변경: 해당 AI 메시지의 **직전 user 메시지**를 기준으로 `/api/ai/chat`를 다시 호출해 실제 답변으로 교체
  - 재생성 시, 해당 AI 메시지 이후 대화는 기본적으로 잘라내(트렁케이트) 일관성을 유지

### C. 백엔드: 캐릭터 API 추가 + AI 캐릭터 조회를 DB로 전환
- `/api/characters` (list/get/create) 엔드포인트를 추가
- AIController/SocketService의 캐릭터 조회를 샘플 데이터에서 **Prisma DB 조회**로 변경

### D. OpenRouter 실제 호출 연결
- `AIService`에서 provider 옵션(`openrouter`)을 받아 실제 OpenRouter로 요청 가능하도록 옵션 전달 경로를 정리
- env의 placeholder 키(`sk-your-...`)는 실제 키로 취급하지 않도록 필터링 로직 추가

---

## 4) 빌드/타입 문제(검증 과정에서 발견된 장애물)

백엔드 TypeScript 빌드(`tsc`)가 기존 타입 문제로 막혀 있었고, 이를 정리해 "빌드 가능한 상태"를 만들었다.
대표적으로:
- Mongoose `Document`의 `model()`과 필드명 `model` 충돌 → `embeddingModel`로 변경
- OpenAI SDK 응답 타입에서 `response.data` optional 처리
- Replicate SDK의 model 문자열 템플릿 리터럴 타입 요구 → 런타임 검증 + 타입 좁히기
- `jsonwebtoken`의 `jwt.sign` 오버로드 타입 정리

프론트는 Next.js build에서 타입체크가 깨지는 지점들을 최소 수정으로 정리했고,
레거시 ESLint 규칙 위반이 빌드를 막지 않도록 `next.config.ts`에서 build 중 lint를 스킵하도록 설정했다.

---

## 5) 실행/검증 방법

### A. 필수 환경
- 백엔드 `.env`에 최소한 아래가 필요
  - `OPENROUTER_API_KEY` (실키)
  - `OPENROUTER_DEFAULT_MODEL` (예: `meta-llama/llama-3.2-3b-instruct:free`)
  - DB 연결 값들(`DATABASE_URL`, `MONGODB_URI`, Redis 설정 등)

### B. 개발 서버 실행
- 백엔드:
  - `npm --prefix packages/backend run dev:clean`
- 프론트:
  - `npm --prefix packages/frontend run dev`

### C. 동작 확인 시나리오
1. `http://localhost:3000` 접속 → 회원가입/로그인
2. `/characters/create`에서 캐릭터 생성
3. 생성된 캐릭터로 `/chat/{characterId}` 이동
4. “안녕” 전송 → 더 이상 `[Mock Response]`가 아니라 OpenRouter 응답이 와야 함
5. AI 메시지의 Regenerate 실행 → 실제 `/api/ai/chat` 재호출로 답변이 갱신되어야 함

---

## 6) 보안 메모 (중요)
- OpenRouter/OpenAI 키가 로그/대화/스크린샷 등에 노출되었을 가능성이 있으면 **즉시 키를 폐기/재발급**하는 것을 권장.
- `.env`는 Git에 커밋되지 않도록 유지.

---

## 7) 한글이 `????` 로 깨져 보이는 문제

### 결론
- 서버/LLM이 UTF-8로 응답해도, **Windows PowerShell 5.1에서 JSON 바디 인코딩/콘솔 디코딩 문제로 한글이 `?`로 치환**될 수 있다.
- 한 번 `?`로 치환된 값이 DB에 저장되면, 브라우저 UI에서도 그대로 `????`로 보인다(서버가 다시 복구해주지 못함).

### 대응
- 캐릭터/메시지 등 한글 데이터는 가능하면 **브라우저 UI(프론트)** 또는 **Node 기반 fetch**로 생성/전송한다.
- 이미 `????`로 저장된 캐릭터는 UI에서 다시 만들거나(DB 직접 수정 포함) 데이터를 교체해야 한다.
- PowerShell로 꼭 호출해야 한다면, 바디를 UTF-8 바이트로 보내는 방식이 안전하다.

---

## 8) 스트리밍(SSE) 모드
- 프론트 채팅에서 `/api/ai/chat/stream` SSE 엔드포인트를 사용해 assistant 응답을 chunk 단위로 누적 표시하도록 변경.
- 전송 및 재생성(Regenerate) 모두 스트리밍 경로를 사용.

### 안정성 보강
- 스트리밍 중복/경합 방지: 새 요청이 시작되면 기존 SSE 스트림을 `AbortController`로 즉시 중단(응답 chunk 섞임 방지)
- 언마운트 정리: 페이지 이동/언마운트 시에도 진행 중 스트림을 abort
- SSE 파서 강화: `\r\n`(CRLF) 정규화 + 멀티라인 `data:`(SSE 스펙) 지원
- UX 안전장치: 새 메시지 전송 시 남아있는 `isStreaming` 커서를 먼저 끄고, 스트리밍 중에는 Regenerate 실행을 막음
- 자동 재시도(UX): 스트리밍이 네트워크 문제로 실패했을 때, **아직 한 글자도 출력되지 않은 경우에 한해 1회 자동 재시도**